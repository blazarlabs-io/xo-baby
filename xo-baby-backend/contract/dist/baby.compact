pragma language_version >= 0.14.0;

import CompactStandardLibrary;

export { CoinInfo };

export ledger round: Counter;
export ledger nonce: Bytes<32>;
export ledger tvl: Uint<64>;

struct RoleNFT {
  role: Bytes<32>,
  validUntil: Bytes<32>
}

export ledger roleNFTs: Map<Bytes<32>, RoleNFT>;

constructor(initNonce: Bytes<32>) {
  nonce = disclose(initNonce);
  round.increment(1);
}

// Generate NFT ID according to the parameters
export circuit generateNFTId(firstname: Bytes<32>, lastname: Bytes<32>, email: Bytes<32>): Bytes<32> {
  round.increment(1);
  const tokenId = persistentHash<Vector<4, Bytes<32>>>([
    pad(32, "baby:nft:"),
    firstname,
    lastname,
    email
  ]);
  return tokenId;
}

// Add Role Token to the ledger mapping nftId <=> RoleToken
export circuit generateRoleBasedNFT(
  nftId: Bytes<32>,
  role: Bytes<32>,
  validUntil: Bytes<32>
): [] {
  round.increment(1);
  const roleNFT = RoleNFT {
    role: disclose(role),
    validUntil: disclose(validUntil)
  };
  roleNFTs.insert(disclose(nftId), roleNFT);
}

// Get Role from NFT from the ledger mapping nftId <=> RoleNFT
export circuit getRoleFromNFT(nftId: Bytes<32>): RoleNFT {
  return roleNFTs.lookup(disclose(nftId));
}


// create child did according to child's name, dob, gender
export circuit createChildId(name: Bytes<32>, birthDate: Bytes<32>, gender: Bytes<32>): Bytes<32> {
    round.increment(1);
    nonce = evolveNonce(round, nonce);

    const childId = persistentHash<Vector<5, Bytes<32>>>([
        pad(32, "baby:child:id:"),
        name,
        birthDate,
        gender,
        nonce
    ]);
    return childId;
}

struct encryptedData {
  childId: Bytes<32>,
  ipfsLink : Bytes<32>,
  AESkey : Bytes<32>
}

export ledger childNFTs : Map<Bytes<32>, encryptedData>;

export circuit generateChildNFT(childId: Bytes<32>, CID: Bytes<32>, AESkey: Bytes<32>): [] {
  round.increment(1);
  const datum = encryptedData {
    childId: disclose(childId),
    ipfsLink: disclose(CID),
    AESkey: disclose(AESkey)
  };
  childNFTs.insert(disclose(childId), datum);
}

export circuit getDataFromChildNFT(childId: Bytes<32>): encryptedData {
  return childNFTs.lookup(disclose(childId));
}

//remove roleNFT from the ledger mapping nftId <=> RoleNFT
export circuit removeRoleNFT(nftId: Bytes<32>): [] {
  roleNFTs.remove(disclose(nftId));
}

export circuit removeChildNFT(childId: Bytes<32>): [] {
  childNFTs.remove(disclose(childId));
}
